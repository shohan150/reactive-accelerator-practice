import { favouriteContext } from "../context";
import { useLocalStorage } from "../hooks";
export default function FavouriteProvider({ children }) {
  // The `setFavourites` function is returned from the `useLocalStorage` hook, which internally manages state using `useState` and `useEffect`. The `useLocalStorage` hook encapsulates the logic for managing state in local storage, providing a way to persist state across sessions.

  // Even though `useState` is not directly used in `favouriteProvider.js`, the `setFavourites` function provided by the `useLocalStorage` hook is essentially a setter function generated by `useState`. When you call `setFavourites` with a new value, it triggers a re-render of the component using that state, just like `setState` does in a component using local state managed by `useState`.

  // So, when you call `setFavourites`, it internally updates the state managed by `useLocalStorage`, which then updates the local storage and triggers a re-render if necessary, ensuring that the component reflects the updated state.
  const [favourites, setFavourites] = useLocalStorage("favourites", []);

  const toggleFavourites = (latitude, longitude, location) => {
    setFavourites([
      ...favourites,
      {
        latitude,
        longitude,
        location,
      },
    ]);
  };

  const removeFromFavourites = (location) => {
    const restFavourites = favourites.filter(
      (fav) => fav.location !== location
    );
    setFavourites(restFavourites);
  };
  return (
    // Now, we don't need to write the functionality of adding and removing inside the component. We declare all the activities related to the favourite context in the FavouriteProvider.jsx file. Now, we can these functions in the project.
    <favouriteContext.Provider
      value={{ favourites, toggleFavourites, removeFromFavourites }}
    >
      {children}
    </favouriteContext.Provider>
  );
}
